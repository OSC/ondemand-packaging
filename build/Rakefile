require 'yaml'
require_relative 'build_lib'

def dist_configs(dist, k1, k2 = nil)
  configs = {
    'el7' => {
      'MOCK_CONFIG' => {
        'ondemand-runtime' => 'epel-7-x86_64',
        'ondemand-sqlite' => 'epel-7-x86_64',
        'rubygem-bundler' => 'epel-7-x86_64',
        'default' => 'ondemand-el7-x86_64',
      },
      'MOCK_FIX'    => 'rpm --rebuilddb',
      #'MOCK_CMD'    => '--scrub yum-cache',
      'PACKAGE'     => {
        'mod_auth_openidc' => "--define 'scl httpd24'",
      },
      'MOCK_PACKAGES' => {
        'ondemand-dex' => ['ondemand-scldevel'],
        'rubygem-bundler' => ['ondemand-runtime','ondemand-scldevel'],
        'default' => [],
      },
      'MOCK_REPOS' => {
        'ondemand-sqlite' => 'ondemand-web-build-base',
        'rubygem-bundler' => 'ondemand-web-build-base',
        'default' => nil,
      },
    },
    'el8' => {
      'MOCK_CONFIG' => {
        'ondemand-runtime' => 'epel-8-x86_64',
        'ondemand-sqlite' => 'epel-8-x86_64',
        'rubygem-bundler' => 'epel-8-x86_64',
        'default' => 'ondemand-el8-x86_64',
      },
      # Debugging
      #'MOCK_FIX' => 'ls -la /var/lib/rpm/* ; rpm -qa | sort ; mv /var/lib/rpm /var/lib/rpm.bak ; rpm --rebuilddb ; /usr/lib/rpm/rpmdb_dump /var/lib/rpm.bak/Packages | /usr/lib/rpm/rpmdb_load /var/lib/rpm/Packages ; rpm -qa | sort',
      # Hack to work around issues with rpmdb and overlayfs
      #'MOCK_FIX'    => 'mv /var/lib/rpm /var/lib/rpm.bak ; rpm --rebuilddb ; /usr/lib/rpm/rpmdb_dump /var/lib/rpm.bak/Packages | /usr/lib/rpm/rpmdb_load /var/lib/rpm/Packages',
      'PACKAGE'     => {
      },
      'MOCK_PACKAGES' => {
        'ondemand-dex' => ['ondemand-scldevel'],
        'rubygem-bundler' => ['ondemand-runtime','ondemand-scldevel'],
        'default' => [],
      },
      'MOCK_REPOS' => {
        'ondemand-sqlite' => 'ondemand-web-build-base',
        'rubygem-bundler' => 'ondemand-web-build-base',
        'default' => nil,
      },
    },
  }
  # Use dig once using newer Ruby
  # return configs.dig(*args)
  config = configs.fetch(dist, {}).fetch(k1, nil)
  if k2
    config = configs.fetch(dist, {}).fetch(k1, {}).fetch(k2, nil)
    if config.nil?
      config = configs.fetch(dist, {}).fetch(k1, {}).fetch('default', nil)
    end
  end
  config
end



DISTRO = ENV['DISTRO']
PACKAGE = ENV['PACKAGE']
VERSION = ENV['GIT_TAG'].to_s.gsub(%r{^v}, '')
BUILDBOX_IMAGE = ENV['BUILDBOX_IMAGE']
BUILDBOX_IMAGE_DEFINE = "--define 'build_image #{BUILDBOX_IMAGE}'"
PACKAGE_NAME = File.basename(PACKAGE)
DEB_NAME = "#{PACKAGE_NAME}-#{VERSION}"
WORK_DIR = "/work/#{DISTRO}"
OUTPUT_DIR = "/output/#{DISTRO}"
BUILD_DIR = "/package/build"
MOCK_CONFIG = dist_configs(DISTRO, 'MOCK_CONFIG', PACKAGE_NAME)
MOCK_FIX = dist_configs(DISTRO, 'MOCK_FIX')
MOCK_CMD = dist_configs(DISTRO, 'MOCK_CMD')
MOCK_ARGS = dist_configs(DISTRO, 'PACKAGE', PACKAGE_NAME)
MOCK_PACKAGES = dist_configs(DISTRO, 'MOCK_PACKAGES', PACKAGE_NAME)
MOCK_REPOS = dist_configs(DISTRO, 'MOCK_REPOS', PACKAGE_NAME)
if ENV['DEBUG'] == 'true'
  cmd_suffix = ''
else
  cmd_suffix = '2>/dev/null 1>/dev/null'
end

if ENV['GIT_TAG'] && ! ENV['GIT_TAG'].empty?
  git_tag = ENV['GIT_TAG'].split('-')
  git_prerelease_tag = ENV['GIT_TAG'].split('_')
  git_tag_version = git_tag[0]
  if git_tag_version.start_with?('v')
    git_tag_version = git_tag_version[1..-1]
  end
  GIT_TAG_DEFINE = "--define 'git_tag #{ENV['GIT_TAG']}'"
  if git_prerelease_tag.size >= 2
    git_prerelease_verison = git_prerelease_tag[0]
    if git_prerelease_verison.start_with?('v')
      git_prerelease_verison = git_prerelease_verison[1..-1]
    end
    VERSION_DEFINE = "--define 'package_version #{git_prerelease_verison}'"
    if git_tag.size >= 2
      prerelease = git_prerelease_tag[1].gsub('-','.')
      RELEASE_DEFINE = "--define 'package_release 0.#{prerelease}'"
    else
      RELEASE_DEFINE = "--define 'package_release 0.#{git_prerelease_tag[1]}.1'"
    end
  else
    VERSION_DEFINE = "--define 'package_version #{git_tag_version}'"
    if git_tag.size >= 2
      RELEASE_DEFINE = "--define 'package_release #{git_tag[1]}'"
    else
      RELEASE_DEFINE = ''
    end
  end
else
  GIT_TAG_DEFINE = ''
  VERSION_DEFINE = ''
  RELEASE_DEFINE = ''
end

def packaging_config(path)
  return {} unless File.exists?(path)
  config = YAML.load_file(path)
  config
end

def get_spec(dir)
  files = Dir["#{dir}/*.spec"]
  files[0]
end

def get_srpm()
  files = Dir['/home/ood/rpmbuild/SRPMS/*.src.rpm']
  files[0]
end

def get_rpms(dir)
  rpms = []
  Dir["#{dir}/*.rpm"].each do |rpm|
    if rpm =~ /\.src\.rpm$/
      next
    end
    rpms << rpm
  end
  rpms
end

namespace :rpm do
  desc "Bootstrap build environment"
  task :bootstrap do |task|
    puts "== #{task.name} ==".blue
    puts "\tClean build environment".blue
    sh "rm -rf /home/ood/rpmbuild/*/*"
    if ENV['GPG_SIGN'] == 'true'
      puts "\tBootstrap GPG".blue
      sh "echo '%_gpg_name #{ENV['GPG_NAME']}' >> ~/.rpmmacros"
      sh 'rm -rf ~/.gnupg'
      sh "gpg --import /ondemand-packaging/ondemand.sec #{cmd_suffix}"
      if ENV['GPG_PUBKEY'] && ! ENV['GPG_PUBKEY'].empty?
        sh "rpm --import /ondemand-packaging/stage/#{ENV['GPG_PUBKEY']} #{cmd_suffix}"
      end
    end
  end

  desc "Build SRPM"
  task :srpm => :bootstrap do |task|
    puts "== #{task.name} ==".blue
    sh 'find /package -maxdepth 1 -type f -exec cp {} /home/ood/rpmbuild/SOURCES/ \;'
    sh 'find /package -maxdepth 1 -mindepth 1 -type d -exec cp -r {} /home/ood/rpmbuild/SOURCES/ \;'
    spec = get_spec('/home/ood/rpmbuild/SOURCES')
    spec_files = `spectool #{GIT_TAG_DEFINE} #{VERSION_DEFINE} #{RELEASE_DEFINE} --list-files #{spec}`
    sources = []
    spec_files.each_line do |line|
      l = line.split(' ')
      s = l[1]
      source = File.basename(s)
      sources << source
    end
    get_sources = false
    sources.each do |source|
      f = File.join('/home/ood/rpmbuild/SOURCES', source)
      if ! File.exists?(f)
        get_sources = true
      end
    end
    if ENV['SKIP_DOWNLOAD'] == 'true'
      puts "\tSKIP_DOWNLOAD detected, skipping download sources".blue
      get_sources = false
    end
    if get_sources
        puts "\tDownloading sources defined in #{spec}".blue
        sh "spectool #{GIT_TAG_DEFINE} #{VERSION_DEFINE} #{RELEASE_DEFINE} -g -R -S #{spec} #{cmd_suffix}"
    end
    puts "\tBuild SRPM for #{spec}".blue
    sh "rpmbuild #{GIT_TAG_DEFINE} #{VERSION_DEFINE} #{RELEASE_DEFINE} #{BUILDBOX_IMAGE_DEFINE} -bs #{spec} #{cmd_suffix}"
  end

  desc "Build RPM"
  task :rpm => :srpm do |task|
    puts "== #{task.name} ==".blue
    srpm = get_srpm()
    puts "\tCleaning #{WORK_DIR}".blue
    sh "rm -rf #{WORK_DIR}/*"
    sh "mkdir -p #{WORK_DIR}"
    if MOCK_FIX
      puts "\tFix mock".blue
      sh "sudo mock -r #{MOCK_CONFIG} --no-clean --no-cleanup-after --chroot '#{MOCK_FIX}' #{cmd_suffix}"
    end
    if MOCK_CMD
      puts "\tMOCK CMD: #{MOCK_CMD}".blue
      sh "mock -r #{MOCK_CONFIG} --no-clean --no-cleanup-after #{MOCK_CMD} #{cmd_suffix}"
    end
    if MOCK_REPOS
      enablerepo = "--enablerepo=#{MOCK_REPOS}"
    else
      enablerepo = ''
    end
    if MOCK_PACKAGES
      MOCK_PACKAGES.each do |package|
        puts "\tInstall #{package} into mock environment".blue
        sh "sudo mock -r #{MOCK_CONFIG} #{enablerepo} --no-clean --no-cleanup-after --install '#{package}' #{cmd_suffix}"
      end
    end
    puts "\tRPM from #{srpm} for #{PACKAGE} #{DISTRO}".blue
    cmd = [
      "/usr/bin/mock --verbose -r #{MOCK_CONFIG}",
      GIT_TAG_DEFINE, VERSION_DEFINE, RELEASE_DEFINE,
      BUILDBOX_IMAGE_DEFINE,
      '--enable-network',
      '--no-clean', '--no-cleanup-after',
      '--resultdir', WORK_DIR,
    ]
    if MOCK_ARGS
      puts "\tUsing extra mock args: #{MOCK_ARGS}".blue
      cmd << MOCK_ARGS
    end
    cmd << "rebuild #{srpm} #{cmd_suffix}"
    sh cmd.join(' ')
  end

  desc "Build Finish"
  task :finish => :rpm do |task|
    puts "== #{task.name} ==".blue
    if ! File.directory?(OUTPUT_DIR)
      puts "\tCreating #{OUTPUT_DIR}".blue
      sh "mkdir -p #{OUTPUT_DIR}"
    end
    puts "\tcopy #{WORK_DIR}/*.rpm #{OUTPUT_DIR}/".blue
    sh "cp #{WORK_DIR}/*.rpm #{OUTPUT_DIR}/"
  end

  desc 'Sign RPMs'
  task :gpgsign => :bootstrap do |task|
    puts "== #{task.name} ==".blue
    get_rpms(OUTPUT_DIR).each do |rpm|
      puts "\tGPG signing #{rpm}".blue
      sh "/ondemand-packaging/rpm-sign.exp /ondemand-packaging/.gpgpass #{rpm} #{cmd_suffix}"
    end
  end

  desc 'Build Passenger and NGINX'
  task :passenger_nginx => :bootstrap do |task|
    puts "== #{task.name} ==".blue
    if ENV['GPG_SIGN'] == 'true'
      Rake::Task['build:gpgsign'].invoke
    end
  end

  desc 'Sanity tests'
  task :sanity do |task|
    failure = false
    puts "== #{task.name} ==".blue
    if ENV['GPG_SIGN'] == 'true'
      get_rpms(OUTPUT_DIR).each do |rpm|
        puts "\tTest GPG signing #{rpm}".blue
        output = `rpm -K #{rpm} 2>&1`
        exit_code = $?.exitstatus
        puts output if ENV['DEBUG'] == 'true'
        if exit_code != 0
          puts "\tGPG check failure: exit code #{exit_code}".red
          failure = true
        end
        if output !~ /pgp/
          puts "\tRPM not GPG signed".red
          failure = true
        end
      end
    end
    exit 1 if failure
  end
end

namespace :deb do
  desc "Bootstrap deb builds"
  task :bootstrap do |task|
    puts "== #{task.name} ==".blue
    if ! File.directory?(WORK_DIR)
      puts "\tCreating #{WORK_DIR}".blue
      sh "mkdir -p #{WORK_DIR}"
    end
    sh "cp -a #{BUILD_DIR}/* #{WORK_DIR}/"
    puts "\tExtract source".blue
    Dir.chdir(WORK_DIR) do
      sh "tar -xf #{DEB_NAME}.tar.gz"
    end
    puts "\tBootstrap debian build files".blue
    Dir.chdir(File.join(WORK_DIR, DEB_NAME)) do
      sh "dh_make -s -y --createorig -f ../#{DEB_NAME}.tar.gz #{cmd_suffix} || true"
      sh "dch -b -v #{VERSION} 'Release #{VERSION}' #{cmd_suffix}"
    end
    puts "\tUpdating packages".blue
    sh "sudo apt-get update #{cmd_suffix}"
    sh "sudo apt upgrade -y #{cmd_suffix}"
    puts "\tInstalling dependencies".blue
    Dir.chdir(File.join(WORK_DIR, DEB_NAME)) do
      sh "mk-build-deps --install --remove --root-cmd sudo --tool='apt-get -o Debug::pkgProblemResolver=yes --no-install-recommends --yes' #{cmd_suffix}"
    end
  end
  desc "Build deb package"
  task :build do |task|
    puts "== #{task.name} ==".blue
    config = packaging_config(File.join(WORK_DIR, DEB_NAME, 'debian/packaging.yaml'))
    prepend_path = ""
    if config['prepend_path']
      prepend_path = "--prepend-path=#{config['prepend_path']}"
    end
    ENV['VERSION'] = VERSION
    Dir.chdir(File.join(WORK_DIR, DEB_NAME)) do
      sh "debuild --no-lintian --preserve-env #{prepend_path} #{cmd_suffix}"
    end
  end

  desc "Build Finish"
  task :finish => :build do |task|
    puts "== #{task.name} ==".blue
    if ! File.directory?(OUTPUT_DIR)
      puts "\tCreating #{OUTPUT_DIR}".blue
      sh "mkdir -p #{OUTPUT_DIR}"
    end
    puts "\tcopy #{WORK_DIR}/*.deb #{OUTPUT_DIR}/".blue
    sh "cp #{WORK_DIR}/*.deb #{OUTPUT_DIR}/"
  end
end

namespace :run do
  task :rpm do
    Rake::Task['rpm:rpm'].invoke
    Rake::Task['rpm:finish'].invoke
    if ENV['GPG_SIGN'] == 'true'
      Rake::Task['rpm:gpgsign'].invoke
    end
    Rake::Task['rpm:sanity'].invoke
  end

  task :deb do
    Rake::Task['deb:bootstrap'].invoke
    Rake::Task['deb:build'].invoke
    Rake::Task['deb:finish'].invoke
  end
end
